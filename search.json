[
  {
    "objectID": "kinetics.html",
    "href": "kinetics.html",
    "title": "Chemical Kinetics",
    "section": "",
    "text": "source\n\nsteady_state_calc\n\n steady_state_calc (kf1:float, kr1:float, kf2:float, kr2:float)\n\nCalculate the steady state equilibrium of reaction D<->I<->N, given the rate of the forwards and backwards processes at each step\n\n\n\n\nType\nDetails\n\n\n\n\nkf1\nfloat\nrate constant for D->I\n\n\nkr1\nfloat\nrate constant for I->D\n\n\nkf2\nfloat\nrate constant for I->N\n\n\nkr2\nfloat\nrate constant for N->I\n\n\n\nFor instance, for varying concentrations of urea:\nConsider the reaction\n\\[D  \\xrightleftharpoons[k_{u}^{R15}]{k_{f}^{R15}}  I  \\xrightleftharpoons[k_{u}^{R16}]{k_{f}^{R16}} N\\]\nIn the steady state, the rate of change of all components it null and so\n\\[k_{u}^{R15}[I]-k_{f}^{R15}[D]=0\\] \\[k_{f}^{R16}[I]-k_{u}^{R16}[N]=0\\]\nand with an additional restriction that the total number of substances is constant: wlg let that be 1:\n\\[[D]+[I]+[N]=1\\]\nAs such this can be represented as a matrix:\n\\[\\begin{pmatrix}-k_{f}^{R15}&k_{u}^{R15}&0\\\\ 0 & k_{f}^{R16} & -k_{u}^{R16}\\\\ 1&1&1\\end{pmatrix}\\begin{pmatrix} [D] \\\\ [I] \\\\ [N] \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\\]\nAnd thus\n\\[\\begin{pmatrix} [D] \\\\ [I] \\\\ [N] \\end{pmatrix} = \\frac{1}{k_{f}^{R15}k_{f}^{R16}+k_{f}^{R15}k_{u}^{R16}+k_{u}^{R15}k_{u}^{R16}}\\begin{pmatrix}-k_{f}^{R16}-k_{u}^{R16}&k_{u}^{R15}&k_{u}^{R15}k_{u}^{R16}\\\\ k_{u}^{R16} & k_{f}^{R15} & k_{f}^{R15}k_{u}^{R16}\\\\ k_{f}^{R16}&-k_{f}^{R15}-k_{u}^{R15}&k_{f}^{R15}k_{f}^{R16}\\end{pmatrix}\\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\\]\n\nkf1 = 26000\nkr1 = 0.06\nkf2 = 730\nkr2 = 0.00075\nurea_conc = np.linspace(0, 8, num=10000)\nss_conc = np.array([steady_state_calc(kf1*np.exp(-1.68*conc), kr1*np.exp(0.95*conc), kf2*np.exp(-1.72*conc), kr2*np.exp(1.20*conc)) for conc in urea_conc])\n\n\nplt.plot(urea_conc,ss_conc[:, 0],label='D')\nplt.plot(urea_conc,ss_conc[:, 1],label='I')\nplt.plot(urea_conc,ss_conc[:, 2],label='N')\nplt.xlabel('[Urea]/ M')\nplt.ylabel('Fraction of Species')\nplt.legend()\nplt.show()\n\n\n\n\n\nsource\n\n\noreg_calc\n\n oreg_calc (concs:list, method:str='Euler', tmax:float=90, dt:float=2e-06,\n            k1:float=1.34, k2:float=1600000000.0, k3:float=8000.0,\n            k4:float=40000000.0, k5:float=1)\n\nCalculates the time dependent concentrations of species in the oregonator system using the Euler method\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nconcs\nlist\n\nthe concentrations [A,B,X,Y,Z,P,Q]\n\n\nmethod\nstr\nEuler\nthe method to use for the integrator\n\n\ntmax\nfloat\n90\nthe interval over which to run the integrator\n\n\ndt\nfloat\n2e-06\nthe time step for the integrator\n\n\nk1\nfloat\n1.34\nthe rate constant for A + Y -> X + P\n\n\nk2\nfloat\n1600000000.0\nthe rate cosntant for X + Y -> P\n\n\nk3\nfloat\n8000.0\nthe rate constant for B + X -> 2X + Z\n\n\nk4\nfloat\n40000000.0\nthe rate constant for 2X -> Q\n\n\nk5\nfloat\n1\nthe rate constant for Z -> Y\n\n\n\nThe currently implemented methods are Euler’s method ('Euler'), the midpoint method ('midpoint'), Heun’s 3rd order method ('Heun3'), Third-order Strong Stability Preserving Runge-Kutta ('SSPRK3') and the classical Runge Kutta 4th order method ('RK4'): Butcher tableaus for all methods can be found here (all are explicit methods). However, Euler’s method remains the fastest of these as the minimum timestep does not increase enough to outweigh the increase in complexity from any other method.\n\nA, B, X, Y, Z, P, Q = 0.06, 0.06, 10**(-9.8),10**(-6.52), 10**(-7.32), 0, 0\nconcs = [A, B, X, Y, Z, P, Q]\nt, conc_t= oreg_calc(concs, method = 'Euler', dt = 2e-6)\nAs, Bs, Xs, Ys, Zs, Ps, Qs = conc_t\n\n\nplt.plot(t[::10000],As[::10000],label='A')\nplt.plot(t[::10000],Bs[::10000],label='B')\nplt.yscale('log')\nplt.xlabel('time/ s')\nplt.ylabel('Concentration/ M')\nplt.legend(bbox_to_anchor =(1.15, 0.6))\nplt.show()\n\n\n\n\n\nplt.plot(t[::10000],Xs[::10000],label='X')\nplt.plot(t[::10000],Ys[::10000],label='Y')\nplt.plot(t[::10000],Zs[::10000],label='Z')\nplt.yscale('log')\nplt.xlabel('time/ s')\nplt.ylabel('Concentration/ M')\nplt.legend(bbox_to_anchor =(1.15, 0.6))\nplt.show()\n\n\n\n\n\nplt.plot(t[::10000],Ps[::10000],label='P')\nplt.plot(t[::10000],Qs[::10000],label='Q')\nplt.yscale('log')\nplt.xlabel('time/ s')\nplt.ylabel('Concentration/ M')\nplt.legend(bbox_to_anchor =(1.15, 0.6))\nplt.show()\n\n\n\n\n\nA, B, X, Y, Z, P, Q = 0.06, 0.06, 10**(-9.8),10**(-6.52), 10**(-7.32), 0, 0\nconcs = [A, B, X, Y, Z, P, Q]\nt, conc_t= t, conc_t= oreg_calc(concs, method = 'RK4', dt = 3e-6)\nAs, Bs, Xs, Ys, Zs, Ps, Qs = conc_t\n\n\nplt.plot(t[::10000],As[::10000],label='A')\nplt.plot(t[::10000],Bs[::10000],label='B')\nplt.yscale('log')\nplt.xlabel('time/ s')\nplt.ylabel('Concentration/ M')\nplt.legend(bbox_to_anchor =(1.15, 0.6))\nplt.show()\n\n\n\n\n\nplt.plot(t[::10000],Xs[::10000],label='X')\nplt.plot(t[::10000],Ys[::10000],label='Y')\nplt.plot(t[::10000],Zs[::10000],label='Z')\nplt.yscale('log')\nplt.xlabel('time/ s')\nplt.ylabel('Concentration/ M')\nplt.legend(bbox_to_anchor =(1.15, 0.6))\nplt.show()\n\n\n\n\n\nplt.plot(t[::10000],Ps[::10000],label='P')\nplt.plot(t[::10000],Qs[::10000],label='Q')\nplt.yscale('log')\nplt.xlabel('time/ s')\nplt.ylabel('Concentration/ M')\nplt.legend(bbox_to_anchor =(1.15, 0.6))\nplt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ChemIITools",
    "section": "",
    "text": "Documentation can be found at https://kgrewal1.github.io/ChemIITools/"
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "ChemIITools",
    "section": "Install",
    "text": "Install\npip install ChemIITools"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "ChemIITools",
    "section": "How to use",
    "text": "How to use\n\nSolve the Huckel Equation\nEasily solve the Huckel equation for complex systems\n\nmol = Huckel(\"c1cc2ccc3ccc4ccc5ccc6ccc1c7c2c3c4c5c67\")\nprint(mol)\nmol.molecule\n\nHuckel Energies (degeneracy) for c1cc2ccc3ccc4ccc5ccc6ccc1c7c2c3c4c5c67: [-2.675 (1)]  [-2.214 (2)]  [-1.675 (2)]  [-1.539 (1)]  [-1.214 (1)]  [-1.000 (3)]  [-0.539 (2)]  [0.539 (2)]  [1.000 (3)]  [1.214 (1)]  [1.539 (1)]  [1.675 (2)]  [2.214 (2)]  [2.675 (1)] \n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmol.plot()\n\n\n\n\n\n\nParse .out files and plot energy surfaces\nPlot potential energy surfaces of symmetric triatomics and find the vibrational frequencies\n\nsurface_plot(h2o_vals)\n\n\n\n\n\nr_opt, theta_opt, nu_r, nu_theta = vib_calc(h2o_vals)\nprint('the optimum bond length of water is ', r_opt, ' angstroms with angle ', theta_opt, ' degrees' )\nprint('the stretching frequency ', round(nu_r), ' cm-1 and bending frequency ', round(nu_theta), ' cm-1' )\n\nthe optimum bond length of water is  0.95  angstroms with angle  105.0  degrees\nthe stretching frequency  3113  cm-1 and bending frequency  1665  cm-1\n\n\n\n\nCalculate steady state concentrations\nFind the steady state concentration for chemical systems of the form \\[D  \\xrightleftharpoons[k_{u}^{R15}]{k_{f}^{R15}}  I  \\xrightleftharpoons[k_{u}^{R16}]{k_{f}^{R16}} N\\]\n\nkf1 = 26000\nkr1 = 0.06\nkf2 = 730\nkr2 = 0.00075\nurea_conc = np.linspace(0, 8, num=1000)\nss_conc = np.array([steady_state_calc(kf1*np.exp(-1.68*conc), kr1*np.exp(0.95*conc), kf2*np.exp(-1.72*conc), kr2*np.exp(1.20*conc)) for conc in urea_conc])\nplt.plot(urea_conc,ss_conc[:, 0],label='D')\nplt.plot(urea_conc,ss_conc[:, 1],label='I')\nplt.plot(urea_conc,ss_conc[:, 2],label='N')\nplt.xlabel('[Urea]/ M')\nplt.ylabel('Fraction of Species')\nplt.legend()\nplt.show()\n\n\n\n\n\n\nCaclualte time evolution of a chemical system\n\nA, B, X, Y, Z, P, Q = 0.06, 0.06, 10**(-9.8),10**(-6.52), 10**(-7.32), 0, 0\nconcs = [A, B, X, Y, Z, P, Q]\nt, conc_t= oreg_calc(concs)\nAs, Bs, Xs, Ys, Zs, Ps, Qs = conc_t\n\n\nplt.plot(t[::10000],Xs[::10000],label='X')\nplt.plot(t[::10000],Ys[::10000],label='Y')\nplt.plot(t[::10000],Zs[::10000],label='Z')\nplt.yscale('log')\nplt.xlabel('time/ s')\nplt.ylabel('Concentration/ M')\nplt.legend(bbox_to_anchor =(1.15, 0.6))\nplt.show()\n\n\n\n\n\n\nOptimise Cluster Geometry\n\nlj7 = System(7, '(4*((1/r)**12 -(1/r)**6))')\nlj7.optimise()\nprint(lj7)\nlj7.plot()\n\nEnergy -16.505384, for 7 points"
  },
  {
    "objectID": "energysurfaces.html",
    "href": "energysurfaces.html",
    "title": "Energy Surface",
    "section": "",
    "text": "source\n\nparse_out\n\n parse_out (file)\n\nparses an out file of a symmetric triatomic for the bond length, angle and SCF energy\n\nh2o_vals = {}\nfor filename in os.listdir(h2opath):\n    output = parse_out(os.path.join(h2opath, filename))\n    h2o_vals[output[0]] = output[1]\n\n\nsource\n\n\nsurface_plot\n\n surface_plot (dict, fname=None)\n\nPlots a surface from the output of the regex\n\nsurface_plot(h2s_vals)\n\n\n\n\n\nsource\n\n\nheatmap\n\n heatmap (dict, fname=None)\n\nPlots a heatmap from the output of the regex\n\nheatmap(h2o_vals)\n\n\n\n\n\nsource\n\n\nvib_calc\n\n vib_calc (dict, mass=1.6735575e-27, plot=False)\n\nCalculate optimum bond length and angle and symmetric stretch and bending frequencies. Default mass is that of the hydrogen atom\nAssuming around the equilibrium point, the relevant part of each polynomial is the quadratic, for the stretching frequency: \\[E=E_{0}+\\frac{1}{2}k_{r}(r-\\bar{r})^{2}+\\frac{1}{2}k_{\\theta}(\\theta-\\bar{\\theta})^{2}\\] and thus \\[F = -\\nabla E=\\begin{pmatrix}-k_{r}r\\\\-k_{\\theta}\\theta \\end{pmatrix}\\] and so \\(\\nu_{r} = \\frac{1}{2\\pi}\\sqrt{\\frac{k_{r}}{\\mu_{1}}}\\) and \\(\\nu_{\\theta} = \\frac{1}{2\\pi}\\sqrt{\\frac{k_{\\theta}}{r^{2}\\mu_{2}}}\\), where \\(\\mu_{1}\\approx 2 m_{u}\\) and \\(\\mu_{2}\\approx 0.5 m_{u}\\). For both water and hydrogen disulfide \\(m_{u}\\) is the mass of the hydrogen atom\n\nr_opt, theta_opt, nu_r, nu_theta = vib_calc(h2o_vals, plot= True)\nprint('the optimum bond length of water is ', r_opt, ' angstroms with angle ', theta_opt, ' degrees' )\nprint('the stretching frequency ', round(nu_r), ' cm-1 and bending frequency ', round(nu_theta), ' cm-1' )\n\n\n\n\n\n\n\nthe optimum bond length of water is  0.95  angstroms with angle  105.0  degrees\nthe stretching frequency  3113  cm-1 and bending frequency  1665  cm-1\n\n\nSimilarly for hydrogen sulfide\n\nr_opt, theta_opt, nu_r, nu_theta = vib_calc(h2s_vals, plot= True)\nprint('the optimum bond length of hydrogen sulfide is ', r_opt, ' angstroms with angle ', theta_opt, ' degrees' )\nprint('the stretching frequency ', round(nu_r), ' cm-1 and bending frequency ', round(nu_theta), ' cm-1' )\n\n\n\n\n\n\n\nthe optimum bond length of hydrogen sulfide is  1.35  angstroms with angle  94.0  degrees\nthe stretching frequency  2922  cm-1 and bending frequency  1255  cm-1"
  },
  {
    "objectID": "clusters.html",
    "href": "clusters.html",
    "title": "Cluster Optimisation",
    "section": "",
    "text": "source\n\nCoM\n\n CoM (*vectors)\n\nreturns the CoM of vectors\n\nsource\n\n\nCoMTransform\n\n CoMTransform (*vectors)\n\nTransforms vectors so the CoM is at the origin\n\nsource\n\n\nInertiaTensor\n\n InertiaTensor (*vectors)\n\nreturns the inertia tensor of 3D vectors\n\nsource\n\n\npoint_setup\n\n point_setup (n:int, seed:int=0)\n\nreturns n points distributed on the unit sphere\n\nsource\n\n\ngeom_opt\n\n geom_opt (points, F_calc, iterations=1000, factor=0.0001)\n\noptimises geometry of points in 3D space using gradient descent\n\nsource\n\n\nSystem\n\n System (n:int=7, function:str='(4*((1/r)^12 -(1/r)^6))')\n\nA cluster system, defined by n points and a pairwise potential in term of r, given as a string\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nn\nint\n7\nthe number of atoms in the cluster\n\n\nfunction\nstr\n(4*((1/r)^12 -(1/r)^6))\nthe pairwise potential between any two atoms in the cluster\n\n\n\n\nsource\n\n\nSystem.optimise\n\n System.optimise (riter:int=10000, giter:int=1000, gfactor:int=0.0001,\n                  biter:int=100)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nriter\nint\n10000\nthe number of random initial configurations to consider\n\n\ngiter\nint\n1000\nthe number of gradient descent iterations to consider\n\n\ngfactor\nint\n0.0001\nthe factor for the gradient descent\n\n\nbiter\nint\n100\nthe number of basin hopping iterations to perform\n\n\n\nOptimisation is done by random search, followed by gradient descent followed by using scipy’s basinhopping routine. For the Lennard Jones potential, the results have been checked against the Cambridge Cluster Database and are accurate for 6 decimal places up to \\(n=10\\)\n\nlj7 = System(7)\nlj7.optimise()\n\n\nprint(lj7)\n\nEnergy -16.505384, for 7 points\n\n\n\nlj7.plot()\n\n\n\n\nFor the morse potential in the reduced form \\[\\exp(\\rho_{0} (1-r))(\\exp(\\rho_{0} (1-r))-2)\\] as given on the Cambridge Cluster Database, the results for \\(\\rho_{0} = (3,6,10,14)\\) have been checked against the results on http://doye.chem.ox.ac.uk/jon/structures/Morse/tables.html and are accurate for 7 atoms to 6 dps. For 5 atoms, the results are identical for \\(\\rho_{0} = (6,10,14)\\) but for \\(\\rho_{0} = 3\\), smaller by 0.000001: likely a rounding error.\n\nm7 = System(7, '(exp(3*(1-r)))*(exp(3*(1-r))-2)')\nm7.optimise()\n\n\nprint(m7)\n\nEnergy -17.552961, for 7 points\n\n\n\nm7.plot()\n\n\n\n\nFor 6 points, the value cannot be calculated directly for all but \\(\\rho = 3\\). However, using this geometry as start point, all values can be calculated to within 0.000001.\n\nm6 = System(6, '(exp(3*(1-r)))*(exp(3*(1-r))-2)')\nm6.optimise()\nprint(m6, 'rho = 3')\nm6.function = '(exp(6*(1-r)))*(exp(6*(1-r))-2)' # leave the points as previously optimised but change the pairwise potential\nm6.optimise(riter=0) # do not do any random optimisation steps\nprint(m6, 'rho = 6')\nm6.function = '(exp(10*(1-r)))*(exp(10*(1-r))-2)' # leave the points as previously optimised but change the pairwise potential\nm6.optimise(riter=0) # do not do any random optimisation steps\nprint(m6, 'rho = 10')\nm6.function = '(exp(14*(1-r)))*(exp(14*(1-r))-2)' # leave the points as previously optimised but change the pairwise potential\nm6.optimise(riter=0) # do not do any random optimisation steps\nprint(m6, 'rho = 14')\n\nEnergy -13.544229, for 6 points rho = 3\nEnergy -12.487809, for 6 points rho = 6\nEnergy -12.094943, for 6 points rho = 10\nEnergy -12.018170, for 6 points rho = 14\n\n\n\nsource\n\n\nSystem.xyz\n\n System.xyz (name:str=None)\n\nReturns the coordinates of the system in .xyz format\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\nNone\nname of file to save to: if None prints\n\n\n\nThe final configuration can be output in .xyz format\n\nlj7.xyz()\n\n7\nEnergy -16.505384, for 7 points, calculated by ChemII tools\nHe 0.3849546544 -0.1048571302 0.8689910322\nHe -0.2296806096 0.6400449466 -0.6722498078\nHe -0.5186360529 0.0632089849 0.2373778855\nHe 0.5186360103 -0.0632089496 -0.2373778974\nHe 0.2512385919 0.8659521341 0.3183340784\nHe -0.3931890427 -0.4703826180 -0.7338072527\nHe -0.0133235514 -0.9307573678 0.2187319618"
  },
  {
    "objectID": "huckelsolver.html",
    "href": "huckelsolver.html",
    "title": "Generalised Huckel Solver",
    "section": "",
    "text": "This solver will only work if all \\(p\\) orbitals are equivalent (it will not consider for instance perturbations due to nitrogen in pyridine). The Huckel theory assumptions are: \\[ H_{ij}= \\begin{cases} \\alpha,\\  i=j\\\\ \\beta,\\  i \\text{ adjacent to } j\\\\ 0,\\  \\text{otherwise}\\end{cases} \\] with scaling such that \\(\\alpha = 0\\) and \\(\\beta =-1\\). As such, it can be seen that the resulting Huckel matrix is the negative of the adjacency matrix \\(A\\) where: \\[ A_{ij}= \\begin{cases}  1,\\  i \\text{ adjacent to } j\\\\ 0,\\  \\text{otherwise}\\end{cases} \\]\n\nsource\n\ngenerate_smiles\n\n generate_smiles (l_or_r:str, n:int)\n\ngenerate the smiles of either a straight chain or ring polyene, with n atoms. All carbons will be sp2 hybridised. For linear molecules with an odd number of atoms it will return the anion For rings with 4n+1 atoms it will return the anion eg C5H5- For rings with 4n+3 atoms it will return the cation eg C7H7+\n\n\n\n\nType\nDetails\n\n\n\n\nl_or_r\nstr\nlinear or ring\n\n\nn\nint\nthe number of atoms in the molecule\n\n\n\n\nsource\n\n\nHuckel_solve\n\n Huckel_solve (matrix)\n\nFrom a Huckel matrix input, solve for the Huckel pi system Returns a dictionary of energy levels with the associated (possibly degenerate) wavefunctions\n\nsource\n\n\nHuckel\n\n Huckel (SMILES:str='c1ccccc1')\n\nThe solution to the Huckel equation for a molecule given as SMILES\nThis works in a straightforward manner for chains and rings\n\nmol = generate_smiles('linear', 10)\nmol = Huckel(mol)\nprint(mol)\nmol.molecule\n\nHuckel Energies (degeneracy) for C=CC=CC=CC=CC=C: [-1.919 (1)]  [-1.683 (1)]  [-1.310 (1)]  [-0.831 (1)]  [-0.285 (1)]  [0.285 (1)]  [0.831 (1)]  [1.310 (1)]  [1.683 (1)]  [1.919 (1)] \n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmol.plot()\n\n\n\n\n\nmol = generate_smiles('ring', 6)\nmol = Huckel(mol)\nprint(mol)\nmol.molecule\n\nHuckel Energies (degeneracy) for C1=CC=CC=C1: [-2.000 (1)]  [-1.000 (2)]  [1.000 (2)]  [2.000 (1)] \n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmol.plot()\n\n\n\n\nSimilarly, it works for more complkex 3d structures (though rdkit struggles to show their structure in the output skeletal diagram)\n\ntetrahedrane_smiles = 'C12C3C1C23'\ncubane_smiles = 'C12C3C4C1C5C2C3C45'\ndodecahedrane_smiles = 'C12C3C4C5C1C6C7C2C8C3C9C4C1C5C6C2C7C8C9C12'\nfullerene_smiles = \"c12c3c4c5c2c2c6c7c1c1c8c3c3c9c4c4c%10c5c5c2c2c6c6c%11c7c1c1c7c8c3c3c8c9c4c4c9c%10c5c5c2c2c6c6c%11c1c1c7c3c3c8c4c4c9c5c2c2c6c1c3c42\"\n\n\n# rdkit does consider all bonds, even if all are not shown on the output skeletal diagram: this is mostly apparent for cubane\nmolecule = Chem.MolFromSmiles(cubane_smiles)\nmat = -Chem.GetAdjacencyMatrix(molecule)\nprint(mat)\n\n[[ 0 -1  0 -1  0 -1  0  0]\n [-1  0 -1  0  0  0 -1  0]\n [ 0 -1  0 -1  0  0  0 -1]\n [-1  0 -1  0 -1  0  0  0]\n [ 0  0  0 -1  0 -1  0 -1]\n [-1  0  0  0 -1  0 -1  0]\n [ 0 -1  0  0  0 -1  0 -1]\n [ 0  0 -1  0 -1  0 -1  0]]\n\n\n\ntetrahedrane = Huckel(tetrahedrane_smiles)\nprint(tetrahedrane)\ntetrahedrane.plot()\n\nHuckel Energies (degeneracy) for C12C3C1C23: [-3.000 (1)]  [1.000 (3)] \n\n\n\n\n\n\ncubane = Huckel(cubane_smiles)\nprint(cubane)\ncubane.plot()\n\nHuckel Energies (degeneracy) for C12C3C4C1C5C2C3C45: [-3.000 (1)]  [-1.000 (3)]  [1.000 (3)]  [3.000 (1)] \n\n\n\n\n\n\ndodecahedrane = Huckel(dodecahedrane_smiles)\nprint(dodecahedrane)\ndodecahedrane.plot()\n\nHuckel Energies (degeneracy) for C12C3C4C5C1C6C7C2C8C3C9C4C1C5C6C2C7C8C9C12: [-3.000 (1)]  [-2.236 (3)]  [-1.000 (5)]  [0.000 (4)]  [2.000 (4)]  [2.236 (3)] \n\n\n\n\n\n\nfullerene = Huckel(fullerene_smiles)\nprint(fullerene)\nfullerene.plot()\n\nHuckel Energies (degeneracy) for c12c3c4c5c2c2c6c7c1c1c8c3c3c9c4c4c%10c5c5c2c2c6c6c%11c7c1c1c7c8c3c3c8c9c4c4c9c%10c5c5c2c2c6c6c%11c1c1c7c3c3c8c4c4c9c5c2c2c6c1c3c42: [-3.000 (1)]  [-2.757 (3)]  [-2.303 (5)]  [-1.820 (3)]  [-1.562 (4)]  [-1.000 (9)]  [-0.618 (5)]  [0.139 (3)]  [0.382 (3)]  [1.303 (5)]  [1.438 (3)]  [1.618 (5)]  [2.000 (4)]  [2.562 (4)]  [2.618 (3)] \n\n\n\n\n\nIt is also possible to manually overwrite the Huckel matrix in order to deal with species such as pyridine:\n\npyridine = Huckel('n1ccccc1')\npyridine.molecule\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Huckel matrix at the moment is still only the negative of the adjacency matrix, and so is the same as that of benzene\n\npyridine.matrix\n\narray([[ 0, -1,  0,  0,  0, -1],\n       [-1,  0, -1,  0,  0,  0],\n       [ 0, -1,  0, -1,  0,  0],\n       [ 0,  0, -1,  0, -1,  0],\n       [ 0,  0,  0, -1,  0, -1],\n       [-1,  0,  0,  0, -1,  0]], dtype=int32)\n\n\nWe can overwrite this matrix: taking the assumption in the A4 course, that \\(\\alpha_{N} = \\alpha+\\beta/2\\) and \\(\\beta_{NC}=0.8\\beta\\)\n\npyridine.matrix = np.array([[ -1/2, -0.8,  0,  0,  0, -0.8],\n       [-0.8,  0, -1,  0,  0,  0],\n       [ 0, -1,  0, -1,  0,  0],\n       [ 0,  0, -1,  0, -1,  0],\n       [ 0,  0,  0, -1,  0, -1],\n       [-0.8,  0,  0,  0, -1,  0]])\n\n\nprint(pyridine)\npyridine.plot()\n\nHuckel Energies (degeneracy) for n1ccccc1: [-1.954 (1)]  [-1.062 (1)]  [-1.000 (1)]  [0.667 (1)]  [1.000 (1)]  [1.849 (1)]"
  }
]